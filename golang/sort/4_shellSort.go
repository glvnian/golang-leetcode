package sort

// 希尔排序
// 希尔排序本质上是对插入排序的一种优化，它利用了插入排序的简单，又克服了插入排序每次只交换相邻两个元素的缺点。它的基本思想是：
//
// 将待排序数组按照一定的间隔分为多个子数组，每组分别进行插入排序。这里按照间隔分组指的不是取连续的一段数组，而是每跳跃一定间隔取一个值组成一组
// 逐渐缩小间隔进行下一轮排序
// 最后一轮时，取间隔为 11，也就相当于直接使用插入排序。但这时经过前面的「宏观调控」，数组已经基本有序了，所以此时的插入排序只需进行少量交换便可完成
// 举个例子，对数组 [84, 83, 88, 87, 61, 50, 70, 60, 80, 99][84,83,88,87,61,50,70,60,80,99] 进行希尔排序的过程如下：
//
// 第一遍（5 间隔排序）：按照间隔 55 分割子数组，共分成五组，分别是 [84, 50], [83, 70], [88, 60], [87, 80], [61, 99][84,50],[83,70],[88,60],[87,80],[61,99]。对它们进行插入排序，排序后它们分别变成： [50, 84], [70, 83], [60, 88], [80, 87], [61, 99][50,84],[70,83],[60,88],[80,87],[61,99]，此时整个数组变成 [50, 70, 60, 80, 61, 84, 83, 88, 87, 99][50,70,60,80,61,84,83,88,87,99]
// 第二遍（2 间隔排序）：按照间隔 22 分割子数组，共分成两组，分别是 [50, 60, 61, 83, 87], [70, 80, 84, 88, 99][50,60,61,83,87],[70,80,84,88,99]。对他们进行插入排序，排序后它们分别变成： [50, 60, 61, 83, 87], [70, 80, 84, 88, 99][50,60,61,83,87],[70,80,84,88,99]，此时整个数组变成 [50, 70, 60, 80, 61, 84, 83, 88, 87, 99][50,70,60,80,61,84,83,88,87,99]。这里有一个非常重要的性质：当我们完成 22 间隔排序后，这个数组仍然是保持 55 间隔有序的。也就是说，更小间隔的排序没有把上一步的结果变坏。
// 第三遍（1 间隔排序，等于直接插入排序）：按照间隔 11 分割子数组，分成一组，也就是整个数组。对其进行插入排序，经过前两遍排序，数组已经基本有序了，所以这一步只需经过少量交换即可完成排序。排序后数组变成 [50, 60, 61, 70, 80, 83, 84, 87, 88, 99][50,60,61,70,80,83,84,87,88,99]，整个排序完成。
//
// 链接：https://leetcode.cn/leetbook/read/sort-algorithms/eu039h/

func shellSort(arr []int) {
	// 间隔序列，在希尔排序中我们称之为增量序
	// gap: 5  2  1
	for gap := len(arr) / 2; gap > 0; gap /= 2 {
		// 分组

		//  groupStartIndex: 0 1 2 3 4 | 0 1  | 0
		for groupStartIndex := 0; groupStartIndex < gap; groupStartIndex++ {
			// 插入排序

			//   5  0 | 6  1| 7 2 | 8 3 | 9 4 || 0  2
			for currentIndex := groupStartIndex + gap; currentIndex < len(arr); currentIndex += gap {
				// currentNumber 站起来，开始找位置

				var currentNumber = arr[currentIndex]
				var preIndex = currentIndex - gap
				for preIndex >= groupStartIndex && currentNumber < arr[preIndex] {
					// 向后挪位置
					arr[preIndex+gap] = arr[preIndex]

					preIndex -= gap
				}

				// currentNumber 找到了自己的位置，坐下
				arr[preIndex+gap] = currentNumber
			}
		}
	}

}
